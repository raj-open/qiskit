#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# IMPORTS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from __future__ import annotations;

from src.thirdparty.code import *;
from src.thirdparty.misc import *;
from src.thirdparty.quantum import *;
from src.thirdparty.render import *;
from src.thirdparty.types import *;

from src.api import *;
from src.widgets import *;
from src.algorithms import *;

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# EXPORTS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

__all__ = [
    'action_display_circuit',
    'action_display_statistics',
    'action_prepare_circuit_and_job',
];

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# CONSTANTS / LOCAL VARIABLES
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# local usage only
_latest = Latest();

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# METHODS - ACTIONS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def action_display_circuit():
    '''
    Displays the main part of the teleportation protocol.
    '''
    print('Quantumcircuit for Teleportation:');
    circuit = teleportation_protocol(include_entanglement=False);
    display(circuit.draw(output=DRAW_MODE.COLOUR.value, cregbundle=False, initial_state=False));
    return;

def action_prepare_circuit_and_job(
    option: BACKEND | BACKEND_SIMULATOR,
    num_samples: int,
    num_shots: int,
):
    '''
    Displays the entire quantum teleoportation protocol for test purposes:

    - initialisation of an entangle state between Alice and Bob
    - sampling of random states to teleport (via 'random' unitaries - in turn generated by random parameters)
    - the main teleportation circuit for the teleportation algorithm
    - the final part involves (Test-)Bob apply the inverses of the 'random' unitaries and measuring against |0⟩.

    @inputs
    - `backend` - an enum value to indicate which backend to use.
    - `num_samples` - number of 'random' states to teleport
    - `num_shots` - number of shots of the job prepared for each random state.
    '''
    @connect_to_backend(option=option, n=3)
    def action(
        option: BACKEND | BACKEND_SIMULATOR,
        backend: QkBackend,
        num_samples: int,
        num_shots: int,
    ):
        simulated = isinstance(option, BACKEND_SIMULATOR);
        _latest.set_backend(option, simulated=simulated);
        print('Quantumcircuit for testing Teleportation protocol:');
        circuit_scheme, params = teleportation_protocol_test();
        display(circuit_scheme.draw(
            output        = DRAW_MODE.COLOUR.value,
            cregbundle    = False,
            initial_state = True,
        ));

        print(dedent(f'''
        \x1b[1mNOTE:\x1b[0m
        - Random state \x1b[1m|ψ⟩ = U|0⟩\x1b[0m generated at start.
        - To test that \x1b[1m|ψ⟩\x1b[0m was teleported,
          Bob applies inverse of \x1b[1mU\x1b[0m and measures his state.
          If \x1b[1mcbit 3 = |0⟩\x1b[0m, then teleportation successful.
        - Expect cbits 1 + 2 to be uniformly randomly distributed.
        '''));

        # instantiate schema with random values:
        circuits = [
            circuit_scheme.bind_parameters({
                param_i: value_i
                for param_i, value_i in zip(params, values)
            })
            for values in random_unitary_parameters(n=num_samples)
        ];

        # transpile + assemble
        circuits = [ qk_transpile(circuit, backend) for circuit in circuits ];
        for circuit in circuits:
            circuit.name = circuit_scheme.name;

        # run job and obtain results:
        # %qiskit_job_watcher
        job = qk_execute(
            experiments = circuits,
            backend = backend,
            shots = num_shots,
            optimization_level = 3,
        );
        _latest.set_job(job, simulated=simulated);

        print(dedent(f'''
        \x1b[1mNOTE:\x1b[0m
        - backend used: \x1b[1m{backend}\x1b[0m
        - job index: \x1b[1m{job.job_id()}\x1b[0m
        '''));
        return;

    action(num_samples=num_samples, num_shots=num_shots);
    return;

def action_display_statistics(queue: bool = False):
    '''
    Displays statistics of the job results of running the teleportation protocol.

    @inputs
    - `queue` - <boolean> `true` = display widget to choose job from IBM backend queue. `false` = use latest simulation.
    '''
    option = _latest.get_backend(not queue);
    job = _latest.get_job(not queue);
    # extract statitics:
    @recover_job(queue=queue, option=option, job=job, ensure_job_done=True)
    def action(job: IBMQJob):
        result = job.result();
        counts, [counts_alice, counts_bob] = get_counts(result, [0,1], [2]);
        display(
            QkVisualisation.plot_histogram(counts_alice, title='Measurements of Alice\'s QBits'),
            QkVisualisation.plot_histogram(counts_bob, title='Measurements of Bob\'s QBits'),
        );

    action();
    return;
